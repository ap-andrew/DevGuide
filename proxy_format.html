<p>[toc]</p>
<h2>API Facade Structure</h2>

<p>An API facade has the following basic components:</p>
<ul><li>Base Configuration: Primary configuration settings for an API facade</li>
<li>ProxyEndpoint Configuration: Settings for the inbound HTTP connection (from requesting apps to the API platform), request and response flows, and policy attachments</li>
<li>TargetEndpoint Configuration: Settings for the outbound HTTP connection (from the API platform to the backend service), request and response flows, and policy attachments</li>
<li>Flows: ProxyEndpoint and TargetEndpoint request and response pipelines to which polices can be attached.</li>
<li>Policies: XML-formatted configuration files that conform to the API Platform policy schemas</li>
<li>Resources: Scripts, JAR files, and XSLT files referenced by policies to execute custom logic</li></ul>

<h2>API proxy directory structure:</h2>

<p>The components are reflected in the directory structure for an API facade:</p>

<div id="well"><pre>/apiproxy
base_configuration.xml
/proxies
- proxy_endpoint.xml
/targets
- target_endpoint.xml
/policies
- policy1.xml
- policy2.xml
. . .
/resources
  /jsc
    javascript1.js
  /xsl
    xslt1.xsl
  /py
    python_script1.py</pre></div>

<h3>Required settings</h3>
<p>Most API facade contents are optional. The minimal functional API facade requires:</p>

<div id="well"><pre>base_configuration.xml
/proxies
- proxy_endpoint.xml</pre></div>

<p>The most common API facade configuration is:</p>

<div id="well"><pre>base_configuration.xml
/proxies
- proxy_endpoint.xml
/targets
- target_endpoint.xml
/policies</pre></div>


<h3>Base Configuration</h3>
<h3>weatherapi.xml</span></h3>

<p>API facades can be manually created locally or they can generated by the API Platform. API facades are generated by providing a name for the API facade that is unique within an organization on the API Platform.</p>
<p>For example, to generate an API facade called <code>weatherapi</code>, create the following file:</p>

<pre>&lt;APIProxy name="weatherapi"&gt;
&lt;/APIProxy&gt;</pre>

<p>This file defines the most basic API proxy possible:</p>
<p><strong>APIProxy Name:</strong> The name you give this API proxy, which displays in the Management UI and which uniquely identifies this API proxy in your Apigee organization.</p>

<p>An API facade can be generated on the API Platform with the following API call:</p>

$ curl https://api.enterprise.apigee.com/v1/o/{org_name}/apis -X POST -d \
  '{ "name" : "weatherapi" }' \
-H "Content-type:application/json" \
-u myname:mypass

<p>When you create an API facade, a profile for the API proxy is generated on the API Platform. As you can see below, the default representation of an API proxy is JavaScript object notation (JSON).</p>

<div id="well"><pre>{
  "configurationVersion" : {
    "majorVersion" : 4,
    "minorVersion" : 0
  },
  "contextInfo" : "Revision 1 of application weatherapi, in organization {org_name}",
  "createdAt" : 1357172145444,
  "createdBy" : "you@yourcompany.com",
  "displayName" : "weatherapi",
  "lastModifiedAt" : 1357172145444,
  "lastModifiedBy" : "you@yourcompany.com",
  "name" : "weatherapi",
  "policies" : [ ],
  "proxyEndpoints" : [ ],
  "resources" : [ ],
  "revision" : "1",
  "targetEndpoints" : [ ],
  "targetServers" : [ ],
  "type" : "Application"
}</pre></div>

<p>The profile can also be retrieved as XML:</p>

<div id="well"><pre>$ curl https://api.enterprise.apigee.com/v1/o/{org_name}/apis -X POST -d \
'<APIProxy name="weatherapi"></APIProxy>' \
-H "Content-type:application/xml" \
-u myname:mypass</pre>
</div>
<div id="well"><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;APIProxy revision=&quot;1&quot; name=&quot;weatherapi&quot;&gt;
    &lt;ConfigurationVersion minorVersion=&quot;0&quot; majorVersion=&quot;4&quot;/&gt;
    &lt;CreatedAt&gt;1357176743399&lt;/CreatedAt&gt;
    &lt;CreatedBy&gt;you@yourcompany.com&lt;/CreatedBy&gt;
    &lt;DisplayName&gt;weatherapi&lt;/DisplayName&gt;
    &lt;LastModifiedAt&gt;1357176743399&lt;/LastModifiedAt&gt;
    &lt;LastModifiedBy&gt;you@yourcompany.com&lt;/LastModifiedBy&gt;
    &lt;Policies/&gt;
    &lt;ProxyEndpoints/&gt;
    &lt;Resources/&gt;
    &lt;TargetServers/&gt;
    &lt;TargetEndpoints/&gt;
&lt;/APIProxy&gt;</pre></div>


<p>The API proxy profile that is generated demonstrates the complete structure of an API proxy:</p>

<ul><li>APIProxy revision: The sequentially numbered iteration of the API proxy configuration, as maintained by the API Platform</li>
<li>APIProxy name: The unique name of the API proxy</li>
<li>ConfigurationVersion: API Platform version to which the API proxy configuration conforms</li>
<li>CreatedAt: Time when the API proxy was generated on the API platform, formatted in UNIX time</li>
<li>CreatedBy: Email address of the Apigee user who created the API proxy</li>
<li>DisplayName: A user-friendly name for the API proxy</li>
<li>LastModifiedAt: Time when the API proxy was generated on the API platform, formatted in UNIX time</li>
<li>LastModifiedBy: Email address of the Apigee user who created the API proxy o the API platform</li>
<li>Policies: A list of policies that are available for enforcement</li>
<li>ProxyEndpoints: A list of named ProxyEndpoints</li>
<li>Resources: A list of resources (JavaScript, Python, Java, XSLT) available for use by this API proxy</li>
<li>TargetServers: A list of named target servers that may be used for load balancing</li>
<li>TargetEndpoints: A list of named TargetEndpoints</li></ul>

<h3>Proxy Endpoint Configuration</h3>
<h3>/proxies/default.xml</span></h3>
<p>The ProxyEndpoint configuration defines the inbound interface for your API facade. The required configuration elements in a basic facade are:</p>
<p><strong>Base path: </strong>Used to route requests to this API proxy endpoint, based on the URL of the inbound request. The base path defines the URL that needs to invoked to call this API proxy. Messages with this base path appended to the URL defined in the virtual host are routed to this API facade.</p>
<p><strong>Virtual Host: </strong>A setting that defines URL connections for an environment. A virtual host named 'default' is available in all Apigee trial organizations. Your organization may also have a virtual host named 'secure', which provides SSL configuration.</p>
<p><font face="arial, helvetica, sans-serif"><strong>RouteRule</strong>: A pointer to one or more named target definitions (in this example, <code>default</code>) to which requests are passed.</font></p>
<pre>&lt;ProxyEndpoint name="default"&gt;
&nbsp; &nbsp; &lt;HTTPProxyConnection&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;BasePath&gt;/weather&lt;/BasePath&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;VirtualHost&gt;default&lt;/VirtualHost&gt;
&nbsp; &nbsp; &lt;/HTTPProxyConnection&gt;
&nbsp; &lt;RouteRule name="default"&gt;
&nbsp; &nbsp; &lt;TargetEndpoint&gt;default&lt;/TargetEndpoint&gt;
&nbsp; &lt;/RouteRule&gt;
&lt;/ProxyEndpoint&gt;</pre>


<h2>ProxyEndpoint</h2>

<h3>HTTPProxyConnection</h3>
 
<ul>
<li>BasePath: A required string that uniquely identifies the path to an API facade, and which is used by the API Platform to route incoming messages to the proper API facade. The BasePath is a URI fragment (for example <code>/weather</code>) appended to the base URL for an environment (for example, <code>http://apifactory-test.apigee.net</code>) by a requesting client. BasePath must be unique within an environment. Uniqueness is validated by the API Platform when an API facade is imported.</li>
<li>VirtualHost: An optional string that enables an API facade to be associated with specific base URLs for an environment. A VirtualHost is named configuration for a specific domain associated with an environment. Usually, two named VirtualHosts are defined for an environment: <code>default</code> and <code>secure</code>. To ensure that an API facade is available only over HTTPs, for example, set the VirtualHost in the HTTPProxyConnection to <code>secure</code>.</li>
<li>Properties: A set of optional HTTP configuration settings are defined as properties of a ProxyEndpoint</li></ul>

<h3>RouteRule</h3>

<p>A ProxyEndpoint must define at least one RouteRule. A RouteRule defines where an inbound request message is directed after it has been processed by the ProxyEndpoint request pipeline. Usually, the RouteRule points to a named TargetEndpoint configuration.</p>

<p>A RouteRule can contain:</p>
<ul><li>Name: Required attribute, which provides a name for the ProxyEndpoint definition. The default ProxyEndpoint name is <code>default</code> (that is, API facades generated by the Apigee Enterprise UI have one ProxyEndpoint named <code>default</code>. For UI compatibility, it is recommended that ProxyEndpoints be named <code>default</code>).</li>
<li>Condition: An optional conditional statement used for dynamic runtime routing, and which may be based on any variable values. Conditional RouteRules are useful, for example, to enable content-based routing to support backend versioning.</li>
<li>Named TargetEndpoint: String, Not required</li>
<li>URL: String, Not required</li></ul>

<h3>Named TargetEndpoint</h3>

<p>Named TargetEndpoint refers to a TargetEndpoint configuration under <code>/apiproxy/targets</code>.</p>

<p>For example, the following RouteRule refers to the configuration <code>/apiproxy/targets/myTarget.xml</code></p>.

<div id="well"><pre>&lt;RouteRule name=&quot;default&quot;&gt;
	&lt;TargetEndpoint&gt;myTarget&lt;/TargetEndpoint&gt;
&lt;/RouteRule&gt;</pre></div>

<h3>Direct URL Invocation</h3>

<p>A ProxyEndpoint can also directly invoke a backend service. Direct URL invocation bypasses any named TargetEndpoints configuration under <code>/apiproxy/targets</code>). For this reason, TargetEndpoint is an optional API facade configuration, although, in practice, direct invocation from the ProxyEndpoint is not recommended.</p>

<p>For example, the following RouteRule makes an HTTP call to <code>http://api.mycompany.com/v2</code>.</p>

<RouteRule name="default">
	<URL>http://api.mycompany.com/v2</URL>
</RouteRule>
	
<h3>Conditional Routes</h3>

<p>RouteRules can be chained to support dynamic routing at runtime. Inbound requests can be routed to named TargetEndpoint configurations, directly to URLs, or to a combination of the two, based on HTTP headers, message content, query parameters, or contextual information such time of day, locale, etc.</p>

<p>Conditional RouteRules work like other conditional statements on the API Platform. See [node:231] and [node:243].</p>

<p>For example, the following RouteRule combination first evaluates the inbound request to verify the value of an HTTP header. If the HTTP header <code>routeTo</code> has the value <code>TargetEndpoint1</code>, then the request is forwarded to the TargetEndpoint named <code>TargetEndpoint1</code>. If not, then the inbound request is forwarded to <code>http://api.mycompany.com/v2</code>.</p>

<div id="well"><pre>&lt;RouteRule name=&quot;MyRoute&quot;&gt;
     &lt;Condition&gt;request.header.routeTo = &quot;TargetEndpoint1&quot;&lt;/Condition&gt;
     &lt;TargetEndpoint&gt;TargetEndpoint1&lt;/TargetEndpoint&gt;
&lt;/RouteRule&gt;
&lt;RouteRule name=&quot;default&quot;&gt;
     &lt;URL&gt;http://api.mycompany.com/v2&lt;/TargetEndpoint&gt;
&lt;/RouteRule&gt;</pre></div>
	
<h2>TargetEndpoint</h2>
<p>TargetEndpoint is the outbound equivalent of the ProxyEndpoint, and as such functions as HTTP client to an external service or API. An API facade can contain zero or more TargetEndpoints. (ProxyEndpoints can be configured to call URLs directly when required.)
</p>
<h3>TargetEndpoint Configuration</h3>
<h3<code>/targets/default.xml</code></h3>
<p>The TargetEndpoint defines the outbound connection from the  API Platform to the backend service.</span></p>
<p><span style="font-family: arial, helvetica, sans-serif; ">The most important configuration element in a basic facade is:</span></p>
<p><span style="font-family: arial, helvetica, sans-serif; "><strong>URL:</strong> The URL defined in the HTTP connection for the TargetEndpoint defines the network address of the service to which requests are forwarded. Most TargetEndpoint configurations provide only a URL.</p>
<p>For example:</p>
<pre>&lt;TargetEndpoint name="default"&gt;
&nbsp; &nbsp; &lt;HTTPTargetConnection&gt;
&nbsp; &nbsp; &nbsp; &nbsp; &lt;URL&gt;http://weather.yahooapis.com&lt;/URL&gt;
&nbsp; &nbsp; &lt;/HTTPTargetConnection&gt;
&lt;/TargetEndpoint&gt;</pre>

<h2>Advanced TargetEndpoint Configuration</h2>

<p>TargetEndpoints must manage HTTP connections with heterogenous backend infrastructure. For this reason, a number of advanced configuration settings are supported.</p>

<h3>TargetEndpoint SSL Options</h3>

<code>&lt;SSLInfo&gt;</code>
<ul><li>TrustStore</li>
<li>ClientAuthEnabled</li>
<li>KeyStore</li>
<li>KeyAlias</li>
<li>Ciphers</li>
<li>Protocols</li></ul>

<h3>TargetEndpoint with outbound client authentication</h3>

<div id="well"><pre>&lt;TargetEndpoint name=&quot;default&quot;&gt;
  &lt;HttpTargetConnection&gt;
	&lt;URL&gt;https ://myservice.com&lt;/URL&gt;
    &lt;SSLInfo&gt;
      &lt;ClientAuthEnabled&gt;true&lt;/ClientAuthEnabled&gt;
      &lt;KeyStore&gt;myKeystore&lt;/KeyStore&gt;
      &lt;KeyAlias&gt;myKey&lt;/KeyAlias&gt;
      &lt;TrustStore&gt;myTruststore&lt;/TrustStore&gt;
    &lt;/SSLInfo&gt;
  &lt;/HttpTargetConnection&gt;
&lt;/TargetEndpoint&gt;</pre></div>

<p>For detailed instructions, refer to [node:4572]</p>

<h3>TargetEndpoint with Target Load Balancing</h3>

<p>TargetEndpoints support load balancing across multiple named TargetServers using three load balancing algorithms.</p>

For detailed instructions, refer to [node:4562]

<h2>Policies</h2>

<p>The <code>/policies</code> directory in an API proxy contains all policies available to be attached to flows in the API facade. (Policies cannot be shared across API facades. Each API facade requires its own instance of a policy.)</p>

<p>Policies are attached as processing steps to <i>flows</i>. The policy's name is used to reference the policy to be enforced as a processing step. The format of a policy attachment is the following:</p> 

<div id="well"><pre>&lt;Step&gt;&lt;Name&gt;MyPolicy&lt;/Name&gt;&lt;/Step&gt;</pre></div>

<p>Policies are enforced in the order in which they are attached to a flow. For example:</p>

<div id="well"><pre>&lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;</pre></div>
<div id="well"><pre>&lt;Step&gt;&lt;Name&gt;SecondPolicy&lt;/Name&gt;&lt;/Step&gt;</pre></div>

<h2>Flows</h2>

<p>ProxyEndpoint and TargetEndpoint define a pipeline for request and response message processing. A processing pipeline consists of a request flow and a response flow. Each request flow and response flow is subdivided into a PreFlow, one or more optional 'conditional' or 'named' flows, and a PostFlow.</p>

<ul><li>PreFlow: Always executes. Executes before any conditional flows.</li>
<li>PostFlow: Always executes. Executes after any conditional flows.</li></ul>

<p>The API facade processing pipeline executes flows in the following sequence:</p>

<p>Request Pipeline:</p>
<ol><li>Proxy Request PreFlow</li>
<li>Proxy Request Conditional Flows (Optional)</li>
<li>Proxy Request PostFlow</li>
<li>Target Request PreFlow</li>
<li>Target Request Conditional Flows (Optional)</li>
<li>Target Request PostFlow</li></ol>
<p>Response Pipeline:</p>
<ol><li>Target Response PreFlow</li>
<li>Target Response Conditional Flows (Optional)</li>
<li>Target Response PostFlow</li>
<li>Proxy Response PreFlow</li>
<li>Proxy Response Conditional Flows (Optional)</li>
<li>Proxy Response PostFlow</li></ol>

<p> Only those flows with policy attachments need to be configured in ProxyEndpoint or TargetEndpoint configurations. Although they always execute, PreFlow and PostFlow need only be specified in a ProxyEndpoint or TargetEndpoint configuration when a policy needs to be enforced during PreFlow or PostFlow processing.</p>

<p>In contrast to conditional flows, the ordering of PreFlow and PostFlows is not important--the API facade will always execute them at the appropriate point in the pipeline.
</p>

<h3>Conditional Flows</h3>

<p>ProxyEndpoints and TargetEndpoints support an unlimited number of conditional flows (also known as 'named flows').</p>

<p>A common usage of conditional flows is the definition of API resources, as defined by the WADL specification. When an API resource is created in the Management UI, a conditional flow for the associated URI is configured in the API facade.</p>

<p>For example, the following conditional statement defines an API resource <code>/accesstoken</code>. Any inbound request with the URI path suffix <code>/accesstoken</code> will cause this flow to be executed, along with any policies that are attached to the flow. Thus, this API resource functions as an OAuth token endpoint. If the inbound request URI does not include the path suffix <code>/accesstoken</code>, then the flow does not execute (although another conditional flow might). </p>

<div id="well"><pre>&lt;Flows&gt;
&lt;Flow name=&quot;TokenEndpoint&quot;&gt;
  &lt;Condition&gt;proxy.pathsuffix MatchesPath &quot;/accesstoken&quot;&lt;/Condition&gt;
  &lt;Request&gt;
    &lt;Step&gt;&lt;Name&gt;GenerateAccessToken&lt;/Name&gt;&lt;/Step&gt;
  &lt;/Request&gt;
&lt;/Flows&gt;</pre></div>

<p>The sequential ordering of conditional flows is enforced by the API Platform. Conditional flows execute from top to bottom, and the first conditional flow whose condition evaluates to true is executed. For example, in the following flow configuration, any inbound request that does not include the path suffix <code>/first</code> or <code>/second</code> will cause the <code >ThirdFlow</code> to execute, enforcing the policy called <code>Return404</code>.</p>

<div id="well"><pre>
&lt;Flows&gt;
  &lt;Flow name=&quot;FirstFlow&quot;&gt;
    &lt;Condition&gt;proxy.pathsuffix MatchesPath &quot;/first&quot;&lt;/Condition&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name=&quot;SecondFlow&quot;&gt;
    &lt;Condition&gt;proxy.pathsuffix MatchesPath &quot;/second&quot;&lt;/Condition&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;FirstPolicy&lt;/Name&gt;&lt;/Step&gt;
      &lt;Step&gt;&lt;Name&gt;SecondPolicy&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name=&quot;ThirdFlow&quot;&gt;
    &lt;Request&gt;
      &lt;Step&gt;&lt;Name&gt;Return404&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
&lt;/Flows&gt;</pre></div>

<h2>Resources</h2>

<p>The resources directory in an API proxy contains scripts, code, and transformations that can be attached to flows using policies.</p>

Four resource types are supported, each of which has its own directory under <code>/resources</code>:
<ul><li>JavaScript: <code>jsc</code></li>
<li>Python scripts: <code>py</code></li>
<li>Java classes (packaged as JAR files): <code>java</code></li>
<li>XSL transformations: <code>xsl</code></li>
</ul>

<p>Post questions to the <a href="http://support.apigee.com">Apigee Developer Forum</a>.</p>

<p>Back to <a href="/docs/api/quick-starts-index">API Platform Developer Guide</a>.</p>




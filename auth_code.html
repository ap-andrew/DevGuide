<p>[toc]</p>
<p>This topic demonstrates how to setup authorization for your APIs using the OAuth 2.0 authorization code grant type. 
	
<p>The topic references the simpleProxy in the <a href="https://github.com/apigee/api-platform-samples">API Platform Samples</a> available on Github.</p>

<p>In [node:819], you configured the simpleProxy to enforce OAuth 2.0 'client credentials'. In this topic, you configure an OAuth proxy that builds on the policies configured in [node:819]. Instead of the client credential grant type, however, the API proxy that you configure in this topic enforces OAuth 2.0 'authorization code' grant type.</p>

<p>This topic also builds on the API product, developer, and app that you set up in [node:427]. If you have not done so, follow the steps in [node:427] to set up an app to consume your protected API.</p>

<h2>Three-legged OAuth</h2>

<p>The authorization code grant type is sometimes referred to as 'three-legged' OAuth. This name provides a useful visual way to differentiate auth code from client credentials. Unlike the client credentials flow, the auth code flow requires an app to delegate authentication and authorization to a login application developed by the API provider. In other words, another 'leg' or 'hop' is added to flow. The additional leg is accommodated by using a set of redirects.</p>

<p>The auth code grant type is designed primarily for browser-based client apps that communicate directly with the provider API.</p>

<p>The basic three-legged flow is:</p>

<p>First leg:</p>
<ol><li>User navigates to a broswer-based Web app</li>
<li>User clicks the 'login' link in the client app</li>
<li>The login link invokes a URL on the authorization server</li>
<li>The authorization server redirects the request (along with relevant information) to a login application. (This login application is sometimes referred to as a 'consent app'.)</li>
<li>The login application collects the app end users username and password. The login application provides a way for the app end user to authorize the app to access the API on the user behalf.</li>
<li>Once authenticated, the app end user is redirected, along with an auth code, back the app.</li></ol>

<p>Second leg:</p>

<ol><li>The app generates a request for an access token. The request includes the auth code from the first leg, along with the app's consumer key and secret.</li>
<li>The app sends this request to a token endpoint, whose URL has been provided out-of-band.</li>
<p>The token endpoint validates the auth code and the app credentials, and, if they are valid, generates an access token.</p>
<p>The token endpoint returns the access token to the client app.</p></ol>

<p>Third leg:</p>

<ol><li>The app generates a request that includes the access token to the protected API </li>
<li>The protected API validates the access token and evaluates any 'scope' parameters attached to the request</li>
<li>If the access token is valid for the request API resource and scope, then the resource is returned to the app.</p></ol>
	
<p>The app developer must implement an auth code client capable of generating the three requests.</p>

<p>The API provider must implement:</p>
<ol><li>A login app</li>
<li>An authorization server (also called an 'authorization endpoint')</li>
<li>An access token server (also called an 'token endpoint')</li>
<li>A validation step to check access tokens against a token store</li></ol>

<p>The API platform enables you to setup 2, 3, and 4 using policies.</p>

<p>The login app must be implemented by the API provider.</p>

<p>For more background on OAuth, please refer to <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-26">the OAuth 2.0 Specification</a>, or to <a href="http://apigee.com/about/api-best-practices/security-%26-oauth/all">Apigee's best practices for securing APIs with OAuth.</a></p>


<h2>Configure Authorization Endpoint</h2>

The 


<h4>GenerateAuthCode Policy</h4>


<p>Compared with [node:819], you need to add one additional policy : <code>GenerateAuthCode</code>.</p>
<p>This policy configures the authorization endpoint.</p>
<p>Create this policy by creating a file called <code>GenerateAuthCode.xml</code> under <code>apiproxy/policies</code> with the following content:</p>

	<pre>&lt;OAuthV2 name="GenerateAuthCode"&gt;
  &lt;Operation&gt;GenerateAuthorizationCode&lt;/Operation&gt;
  &lt;!-- The authorization code expires in 10 minutes --&gt;
  &lt;ExpiresIn&gt;600000&lt;/ExpiresIn&gt;
  &lt;GenerateResponse/&gt;
&lt;/OAuthV2&gt;</pre>

<h2>Redirect to Login Page</h2>

<p>The authorization endpoint is responsible for redirecting the inbound request to a login app, where the app end user can safely authenticate and authorize the app.</p>

One way to do this is to use a RaiseFault Policy. (You could also implement this functionality using an AssignMessage or ServiceCallout policy, or by implementing an HTTP client in JavaScript, Python, or Java.)

<RaiseFault name="RedirectToLoginApp">
    <IgnoreUnresolvedVariables>true</IgnoreUnresolvedVariables>
    <FaultResponse>
        <Set>
            <Headers>
                <Header name="Location">
                {login_page_URL}
                </Header>
            </Headers>
            <StatusCode>302</StatusCode>
            <ReasonPhrase>Login App Redirect</ReasonPhrase>
        </Set>
    </FaultResponse>
</RaiseFault>



<h4>GenerateAccessToken Policy</h4>
<p>This is the same policy that is configured for client credentials in [node:819], only in this case the policy is configured to support the authorization code grant type.</p>
<p>This policy configures the token endpoint.</p>
<p>Create this policy by as a file called <code>GenerateAccessToken.xml</code> under <code>apiproxy/policies</code> with the following content:</p>

	<pre>&lt;OAuthV2 name="GenerateAccessToken"&gt;
  &lt;GenerateResponse/&gt;
  &lt;!-- &lt;Operation&gt;GenerateAccessToken&lt;/Operation&gt; --&gt;
  &lt;!-- This is in millseconds, so expire in an hour --&gt;
  &lt;ExpiresIn&gt;3600000&lt;/ExpiresIn&gt;
  &lt;SupportedGrantTypes&gt;
    &lt;GrantType&gt;authorization_code&lt;/GrantType&gt;
  &lt;/SupportedGrantTypes&gt;
&lt;GrantType&gt;request.queryparam.grant_type&lt;/GrantType&gt;
&lt;Code&gt;request.queryparam.code&lt;/Code&gt;
&lt;ClientId&gt;request.queryparam.client_id&lt;/ClientId&gt;
&lt;RedirectUri&gt;request.queryparam.redirect_uri&lt;/RedirectUri&gt;
&lt;Scope&gt;request.queryparam.scope&lt;/Scope&gt;
&lt;/OAuthV2&gt;</pre>

	<p>Note the main differences: SupportedGrantTypes now specifies <code>authorization_code</code>. It is possible to list multiple grant types here. You must configure expected locations for each parameter that the client app includes in the request. For auth code, you must specify the location of the auth code, the client ID, the redirect URI, and the scope. For flexibility, the GenerateAccessToken policy supports HTTP headers, query parameters, and form parameters as locations for these parameters.</p>
	<p>The example below demonstrates the same parameters as HTTP headers:</p>
	<pre>&lt;GrantType&gt;request.header.grant_type&lt;/GrantType&gt;
&lt;Code&gt;request.header.code&lt;/Code&gt;
&lt;ClientId&gt;request.header.client_id&lt;/ClientId&gt;
&lt;RedirectUri&gt;request.header.redirect_uri&lt;/RedirectUri&gt;
&lt;Scope&gt;request.header.scope&lt;/Scope&gt;</pre>
	<p>Or mix and match:</p>
	<pre>&lt;GrantType&gt;request.header.grant_type&lt;/GrantType&gt;
&lt;Code&gt;request.header.code&lt;/Code&gt;
&lt;ClientId&gt;request.queryparam.client_id&lt;/ClientId&gt;
&lt;RedirectUri&gt;request.queryparam.redirect_uri&lt;/RedirectUri&gt;
&lt;Scope&gt;request.queryparam.scope&lt;/Scope&gt;</pre>
	<p>Only one location can be configured per parameter.</p>

<h2>Attaching OAuth policies to ProxyEndpoint</h2>
<p>3-legged OAuth requires three endpoints. For the client to initiate the three-legged protocol, you need to define the following endpoints and publish the following URIs:</p>
<ul>
	<li>A URI to access your API:
		<pre>http://{org_name}-test.apigee.net/weather</pre>
	</li>
	<li>A URI to obtain an authorization code:
		<pre>http://{org_name}-test.apigee.net/weather/authorize</pre>
	</li>
	<li>A URI to obtain an access token:
		<pre>http://{org_name}-test.apigee.net/weather/access_token</pre>
	</li>
</ul>


<p>(Note that for security in production, <b>you must use HTTPS for these URLs</b>. In this case, for simplicity, we use HTTP.) These endpoint URIs are published out-of-band. That is, app developers must be informed of these URIs so that they know how to obtain authorization codes and access tokens before they can access an API.</p>
<p>On the API Platform, these endpoints are created using a ProxyEndpoint configuration that defines three conditional flows..</p>
<p>In this example, the respective conditional flows are named <code>GetAuthCode</code>, <code>GetAccessToken</code>, and <code>default</code>.</p>
<p>A different URI must be assigned to each flow:</p>
<ul>
	<li>GetAuthCode: <code>/oauth/authorize</code></li>
	<li>GetAccessToken: <code>/oauth/accesstoken</code></li>
	<li>default: Any URI other than the two defined above</li>
</ul>
<p>With this configuration,to obtain an auth code an app developer calls, for example, <code>http://myorg-test.apigee.net/weather/oauth/authorize</code>.</p>
<p>After obtaining the authorization code, the app uses the code to obtain an access token from the token endpoint at &nbsp;<code>http://myorg-test.apigee.net/weather/oauth/accesstoken</code>.</p>
<p>Finally, the app calls&nbsp;<code>http://myorg-test.apigee.net/weather</code> using the access token to retrieve a weather forecast.</p>
<p>The flow named <code>default</code> is configured with policies that:</p>
<ol>
	<li>Check the URI path suffix (that is, everything after /weather.&nbsp;</li>
	<li>Validate the access token associated with the request</li>
	<li>Retrieve and enforce the quota settings associated with the API product</li>
</ol>
<p>Note that this flow structure makes use of <i>conditional flows</i>. The processing pipeline evaluates the conditional statements for each request received. The conditions are evaluated from top to bottom. If the first two conditions do not evaluate to true, then the 'default' flow is executed for the request, since the default flow has no condition and therefore always executes if a message does not meet the first two conditions.</p>
<p>The following ProxyEndpoint ( <code>apiproxy/proxies/default.xml</code>) implements this flow structure:</p>
<div id="well">
	<pre>&lt;Flows&gt;
  &lt;Flow name="GetAuthCode"&gt;
    &lt;!-- This policy flow is selected when the URI path suffix matches&nbsp;/oauth/authorize --&gt;
    &lt;Condition&gt;proxy.pathsuffix == "/oauth/authorize"&lt;/Condition&gt;
    &lt;Request&gt;
	&lt;Step&gt;&lt;Name&gt;GenerateAuthCode&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name="GetAccessToken"&gt;
    &lt;!-- This policy flow is selected when the URI path suffix matches&nbsp;/oauth/accesstoken --&gt;
    &lt;Condition&gt;proxy.pathsuffix == "/oauth/accesstoken"&lt;/Condition&gt;
    &lt;Request&gt;
	&lt;Step&gt;&lt;Name&gt;GenerateAccessToken&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
  &lt;Flow name="default"&gt;
    &lt;!-- This policy flow is selected for all other API calls --&gt;
    &lt;Request&gt;
	&lt;Step&gt;&lt;Name&gt;ValidateOAuth&lt;/Name&gt;&lt;/Step&gt;
    &lt;/Request&gt;
  &lt;/Flow&gt;
&lt;/Flows&gt;</pre>
</div>
<h2>Importing and deploy the API proxy</h2>
<p>The deploy tool can be used to import the API proxy. Substitute username and password for <code>myname:mypass</code>, and your Apigee organization for <code>myorg</code>.</p>

	<pre>$ python tools/deploy.py -n weatherapi -u myname:mypass -o {org_name} -e test -p / -d simpleProxy</pre>


	<pre>Writing simpleProxy/.DS_Store to ./.DS_Store
Writing simpleProxy/apiproxy/.DS_Store to apiproxy/.DS_Store
Writing simpleProxy/apiproxy/weatherapi.xml to apiproxy/weatherapi.xml
Writing simpleProxy/apiproxy/policies/CheckQuota.xml to apiproxy/policies/CheckQuota.xml
Writing simpleProxy/apiproxy/policies/ClassifyRequest.xml to apiproxy/policies/ClassifyRequest.xml
Writing simpleProxy/apiproxy/policies/GenerateAccessToken.xml to apiproxy/policies/GenerateAccessToken.xml
Writing simpleProxy/apiproxy/policies/GenerateAuthCode.xml to apiproxy/policies/GenerateAuthCode.xml
Writing simpleProxy/apiproxy/policies/ValidateOAuth.xml to apiproxy/policies/ValidateOAuth.xml
Writing simpleProxy/apiproxy/proxies/default.xml to apiproxy/proxies/default.xml
Writing simpleProxy/apiproxy/targets/default.xml to apiproxy/targets/default.xml
Imported new proxy version 9
Environment: test
  Revision: 9 BasePath = /
  State: deployed
</pre>

<h2>Retrieving an access token and making an authorized API request</h2>
<p>To authenticate the user and get the access token, the user's web browser is redirected to the login page (the <code>callback_url</code> for the app) supported by the API.</p>
<p>In the request below:</p>
<ul>
	<li><code>client_id</code> must be the same <code>consumerKey</code> for the requesting</li>
	<li><code>redirect_uri</code>must be the same as the <code>callbackUrl</code> for requesting (in this example <code>login.weatherapp.com</code>)</li>
</ul>
<div id="well">
	<pre>$ curl  "http://myorg-test.apigee.net/weather/oauth/authorize?response_type=code&amp;client_id={consumer_key}&amp;redirect_uri=login.weatherapp.com&amp;scope=READ&amp;state=foobar"</pre>
</div>
<p>This command returns a redirect response:</p>
<div id="well">
	<pre>HTTP/1.1 302 Found Location:login.weatherapp.com?scope=READ&amp;state=foobar&amp;code={auth_code}</pre>
</div>
<p>OAuth client apps must support HTTP <code>302</code> redirect responses. In an actual OAuth app, the URL <code>login.weatherapp.com?scope=READ&amp;state=foobar&amp;code={auth_code}</code> would be invoked by a Web browser. The Web browser would redirect to the login page at <code>login.weatherapp.com</code>.</p>


<p><b>Developing this login app is part of the API provider's responsibility.</b></p>
<p>Note the <code>state</code> parameter. This parameter is designed prevent cross-site request forgery attacks and should be unique for every request. While it is not required, it is strongly recommended.</p>
<p>To retrieve the access token, the login page or pages at <code>login.weatherapp.com&nbsp;</code>makes a POST request to the API proxy.</p>

<p>To construct the POST request, the login app must Base64-encode the consumer key and secret for the app, and then set that as the value of the HTTP <code>Basic authorization</code> header, as in this example:</p>
<div id="well">
	<pre>$ curl -H "Authorization: Basic WExvdEwzUFJ4TmtVR1hoR0FGRFBPcjZmcXR2QWh1WmU6aU5VeUVhT09oOTZLUjNZTA==" "http://{org_name}-test.apigee.net/weather/oauth/accesstoken?grant_type=authorization_code&amp;code=neIu0d8e&amp;redirect_uri=login.weatherapp.com&amp;scope=READ"</pre>
</div>
<p>The API Platform responds with an access token:</p>
<div id="well">
	<pre>{ "issued_at":1345073930832, "scope":"READ", "application_name":"weatherapp", "status":"approved", "organization_id":0, "expires_in":3599, "api_profile_name":"null", "refresh_token":"SlE9lNYf", "access_token":"I29OwHlGRi1AkbBCIRLLMC5efFgu", "refresh_count":0 }</pre>
</div>
<p>The access token returned by the API Platform is now used by the client app to make a request to the protected resource (the target API):</p>
<div id="well">
	<pre>$ curl -H "Authorization: Bearer I29OwHlGRi1AkbBCIRLLMC5efFgu" https://{org_name}-test.apigee.net/weather/forecastrss?w=12797282&amp;</pre>
</div>

<p>Post questions to the <a href="http://support.apigee.com">Apigee Developer Forum</a>.</p>

<p>Back to <a href="/docs/enterprise/content/developer_guide">API Platform Developer Guide</a>.</p>
